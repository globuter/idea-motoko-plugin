{
  parserClass="net.lab0.motoko.parser.MotokoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends("exp_.*")=exp
  extends("pat_.*")=pat

  psiClassPrefix="Motoko"
  psiImplClassSuffix="Impl"
  psiPackage="net.lab0.motoko.psi"
  psiImplPackage="net.lab0.motoko.psi.impl"

  elementTypeHolderClass="net.lab0.motoko.psi.MotokoTypes"
  elementTypeClass="net.lab0.motoko.psi.MotokoElementType"
  tokenTypeClass="net.lab0.motoko.psi.MotokoTokenType"

  psiImplUtilClass="net.lab0.motoko.psi.impl.MotokoPsiImplUtil"
}

motokoFile ::= prog

empty ::=

//<list(X, SEP)> ::=
//    <empty>
//    X
//    X SEP <list(X, SEP)>

//meta list ::= <empty> | <<X>> | <<X>> <<SEP>> <<list <<X>> <<SEP>> >>

//<list1(X, SEP)> ::=
//    X
//    X SEP <list(X, SEP)>

// <sort> ::= (actor | module | object)

sort ::=
    OBJECT
  | ACTOR
  | MODULE

//<func_sort_opt> ::=
//    <empty>
//    'shared' 'query'?
//    'query'

//<shared_pat_opt> ::=
//    <empty>
//    'shared' 'query'? <pat_plain>?
//    'query' <pat_plain>?

shared_pat ::=
    SHARED QUERY? pat?

//<typ_obj> ::=
//    '{' <list(<typ_field>, ';')> '}'
//
//<typ_variant> ::=
//    '{' '#' '}'
//    '{' <list1(<typ_tag>, ';')> '}'

//<typ_nullary> ::=
//    '(' <list(<typ_item>, ',')> ')'
//    <id> ('.' <id>)* <typ_args>?
//    '[' 'var'? <typ> ']'
//    <typ_obj>
//    <typ_variant>

typ_nullary ::=
    L_PAREN typ_item? (COMA typ_item)* R_PAREN
  | ID (POINT ID)* typ_args?
  | L_SQUARE VAR? typ R_SQUARE

//<typ_un> ::=
//    <typ_nullary>
//    '?' <typ_un>

typ_un ::=
    typ_nullary
  | '?' typ_un

//<typ_pre> ::=
//    <typ_un>
//    'async' <typ_pre>
//    <obj_sort> <typ_obj>

typ_pre ::=
    typ_un

//<typ-params> ::=          type parameters
//  < typ-param,* >

typ_params ::=
    L_ANGLE typ_param (COMA typ_param)* R_ANGLE

//<typ-param>
//  <id> <: <typ>           constrained type parameter
//  <id>                    unconstrained type parameter

typ_param ::=
    ID TYPE_CONSTRAINT typ
  | ID

//<typ> ::=
//    <typ_pre>
//    <func_sort_opt> ('<' <list(<typ_bind>, ',')> '>')? <typ_un> '->' <typ>

typ ::=
    typ_pre

//<typ_item> ::=
//    <id> ':' <typ>
//    <typ>

typ_item ::=
    ID COLUMN typ
  | typ

//<typ_args> ::=
//    '<' <list(<typ>, ',')> '>'

typ_args ::=
    L_ANGLE typ (COMA typ)* R_ANGLE

//<typ_field> ::=
//    'var'? <id> ':' <typ>
//    <id> ('<' <list(<typ_bind>, ',')> '>')? <typ_nullary> ':' <typ>

//<typ_tag> ::=
//    '#' <id> (':' <typ>)?

//<typ_bind> ::=
//    <id> '<:' <typ>
//    <id>

//<lit> ::=
//    'null'
//    <bool>
//    <nat>
//    <float>
//    <char>
//    <text>

lit ::=
    NULL
  | bool
  | FLOAT
  | NAT
  | CHAR
  | TEXT

bool ::= TRUE | FALSE

//<unop> ::=
//    '+'
//    '-'
//    '^'

unop ::=
    PLUS
  | MINUS
  | CARRET

//<binop> ::=
//    '+'
//    '-'
//    '*'
//    '/'
//    '%'
//    '**'
//    '+%'
//    '-%'
//    '*%'
//    '**%'
//    '&'
//    '|'
//    '^'
//    '<<'
//    ' >>'
//    '<<>'
//    '<>>'
//    '#'

//<relop> ::=
//    '=='
//    '!='
//    ' < '
//    '<='
//    ' > '
//    '>='

private relational_group ::=
    exp_eq
  | exp_neq
  | exp_lt
  | exp_lte
  | exp_gt
  | exp_gte

exp_eq ::=
    exp EQEQ exp

exp_neq ::=
    exp NEQ exp

exp_lt ::=
    exp L_ANGLE exp  // using '<' instead of " < "

exp_lte ::=
    exp LTE exp

exp_gt ::=
    exp R_ANGLE exp  // using '>' instead of " > "

exp_gte ::=
    exp GTE exp

exp_and ::=
    exp AND exp

exp_or ::=
    exp OR exp

exp_column ::=
    exp COLUMN typ

//<unassign> ::=
//    '+='
//    '-='
//    '^='

//<binassign> ::=
//    '+='
//    '-='
//    '*='
//    '/='
//    '%='
//    '**-'
//    '+%='
//    '-%='
//    '*%='
//    '**%='
//    '&='
//    '|='
//    '^='
//    '<<='
//    '>>='
//    '<<>='
//    '<>>='
//    '@='

//<exp_obj> ::=
//    '{' <list(<exp_field>, ';')> '}'

//<exp_plain> ::=
//    <lit>
//    '(' <list(<exp>, ',')> ')'

exp_plain ::=
    lit
  | exp_parens

private exp_parens ::=
    exp_parens_real

exp_parens_real ::=
    L_PAREN exp? (COMA exp)* R_PAREN

//<exp_nullary> ::=
//    <exp_obj>
//    <exp_plain>
//    <id>

private exp_nullary ::=
//    exp_obj
    exp_plain
  | exp_id

//<exp_post> ::=
//    <exp_nullary>
//    '[' 'var'? <list(<exp_nonvar>, ',')> ']'
//    <exp_post> '[' <exp> ']'
//    <exp_post> '.' <nat>
//    <exp_post> '.' <id>
//    <exp_post> ('<' <list(<typ>, ',')> '>')? <exp_nullary>
//    <exp_post> BANG

private exp_post ::=
    exp_nullary
//  | exp_post_array
//  | exp_post_array
//  | exp_post_id
//  | exp_post_ref
//  | exp_post_generics
//  | exp_post_bang

// Ref: '[' 'var'? <list(<exp_nonvar>, ',')> ']'
exp_post_array ::=
    L_SQUARE VAR? exp_nonvar? (COMA exp_nonvar)* R_SQUARE

// Ref: <exp_post> '[' <exp> ']'
exp_post_array ::=
    exp L_SQUARE exp R_SQUARE

// Ugly hack because resursing on exp_post like in the spec is not possible (private)
// Therefore recursing directly on "function call"-like expression
exp_post_ref ::=
    exp exp_parens

// Ref: <exp_post> '.' <id>
exp_post_id ::=
    exp POINT ID

// Ref: <exp_post> ('<' <list(<typ>, ',')> '>')? <exp_nullary>
// TODO: must be optional. But making it optional makes an infinite recursion.
exp_post_generics ::=
    exp (L_ANGLE typ (COMA typ)* R_ANGLE) exp_nullary

// Ref: <exp_post> BANG
exp_post_bang ::=
    exp BANG

//<exp_un> ::=
//    <exp_post>
//    '#' <id>
//    '#' <id> <exp_nullary>
//    '?' <exp_un>
//    <unop> <exp_un>
//    <unassign> <exp_un>
//    'actor' <exp_plain>
//    'not' <exp_un>
//    'debug_show' <exp_un>


private exp_un ::=
    exp_post


//<exp_bin> ::=
//    <exp_un>
//    <exp_bin> <binop> <exp_bin>
//    <exp_bin> <relop> <exp_bin>
//    <exp_bin> 'and' <exp_bin>
//    <exp_bin> 'or' <exp_bin>
//    <exp_bin> ':' <typ>


//<exp_nondec> ::=
//    <exp_bin>
//    <exp_bin> ':=' <exp>
//    <exp_bin> <binassign> <exp>
//    'return' <exp>?
//    'async' <exp_nest>
//    'await' <exp_nest>
//    'assert' <exp_nest>
//    'label' <id> (':' <typ>)? <exp_nest>
//    'break' <id> <exp_nullary>?
//    'continue' <id>
//    'debug' <exp_nest>
//    'if' <exp_nullary> <exp_nest>
//    'if' <exp_nullary> <exp_nest> 'else' <exp_nest>
//    'try' <exp_nest> <catch>
//    'throw' <exp_nest>
//    'switch' <exp_nullary> '{' <list(<case>, ';')> '}'
//    'while' <exp_nullary> <exp_nest>
//    'loop' <exp_nest>
//    'loop' <exp_nest> 'while' <exp_nest>
//    'for' '(' <pat> 'in' <exp> ')' <exp_nest>
//    'ignore' <exp_nest>
//    'do' <block>
//    'do' '?' <block>

private exp_nondec ::=
    exp_bin_inplace_update
  | exp_binassign
  | exp_bin_if
  | exp_bin_for

exp_bin_inplace_update ::=
    exp IN_PLACE_UPDATE exp

exp_bin_if ::=
    IF exp_nullary exp_nest ELSE exp_nest
  | IF exp_nullary exp_nest

// Ref: 'for' '(' <pat> 'in' <exp> ')' <exp_nest>
exp_bin_for ::=
    FOR L_PAREN pat IN exp R_PAREN exp_nest

//<exp_nonvar> ::=
//    <exp_nondec>
//    <dec_nonvar>

private exp_nonvar ::=
    exp_nondec
//  | dec_nonvar

//<exp> ::=                                                 expressions
// the original grammar entries have been split over the grammar nodes below
//

//parent node:<exp>
// while <exp> <block-or-exp>                              while loop
//parent node:<exp>
// loop <block-or-exp> (while <exp>)?                      loop
//parent node:<exp>
// for ( <pat> in <exp> ) <block-or-exp>                   iteration
//parent node:<exp>
// label <id> (: <typ>)? <block-or-exp>                    label
//parent node:<exp>
// break <id> <exp>?                                       break
//parent node:<exp>
// continue <id>                                           continue
//parent node:<exp>
// return <exp>?                                           return
//parent node:<exp>
// async <block-or-exp>                                    async expression
//parent node:<exp>
// await <block-or-exp>                                    await future (only in async)
//parent node:<exp>
// throw <exp>                                             raise an error (only in async)
//parent node:<exp>
// try <block-or-exp> catch <pat> <block-or-exp>           catch an error (only in async)
//parent node:<exp>
// assert <block-or-exp>                                   assertion
//parent node:<exp>
// <exp> : <typ>                                           type annotation
//parent node:<exp>
// <dec>                                                   declaration
//parent node:<exp>
// ignore <block-or-exp>                                   ignore value
//parent node:<exp>
// do <block>                                              block as expression
//parent node:<exp>
// do ? <block>                                            option block
//parent node:<exp>
// <exp> !                                                 null break
//parent node:<exp>
// debug <block-or-exp>                                    debug expression

exp ::=
    exp_id
  | exp_lit
  | exp_unop
  | exp_binop
  | exp_tuple
  | exp_tuple_projection
  | exp_option_injection
  | exp_object
  | exp_variant_injection
  | exp_object_projection
  | exp_assignment
// TODO: isn't this already covered by the binary version?
//  | exp_unary_update
  | exp_binary_update
  | exp_array
  | exp_array_indexing
// TODO: is this a lambda/closure? Where is it defined?
//  | exp_function_expression
//  | exp_function_call
  | exp_negation
  | exp_conjunction
  | exp_disjunction
  | exp_conditional
  | exp_switch


//parent node:<exp>
// <id>                                                    variable
exp_id ::=
    ID

//parent node:<exp>
// <lit>                                                   literal
exp_lit ::=
    lit

//parent node:<exp>
// <unop> <exp>                                            unary operator
exp_unop ::=
    unop exp

//parent node:<exp>
// <exp> <binop> <exp>                                     binary operator
private exp_binop ::=
    binop_power_group
  | binop_shift_group
  | binop_bitwise_xor_group
  | binop_bitwise_and_group
  | binop_bitwise_or_group
  | binop_multiply_group
  | binop_add_group

//parent node:<exp>
// <exp> <relop> <exp>                                     binary relational operator
private binop_power_group ::=
    exp_exponentiation
//  | exp_wrapping_exponentiation

exp_exponentiation ::=
    exp POW exp

exp_wrapping_exponentiation ::=
    exp WRAPPING_POW exp

private binop_shift_group ::=
    exp_left_shift
  | exp_right_shift
  | exp_left_rotate
  | exp_right_rotate

exp_left_shift ::=
    exp L_SHIFT exp

exp_right_shift ::=
    exp R_SHIFT exp

exp_left_rotate::=
    exp L_ROTATE exp

exp_right_rotate::=
    exp R_ROTATE exp

private binop_bitwise_xor_group::=
    exp_xor

exp_xor ::=
    exp CARRET exp

private binop_bitwise_and_group::=
    exp_bitwise_and

exp_bitwise_and ::=
    exp AMPERSAND exp

private binop_bitwise_or_group ::=
    exp_bitwise_or

exp_bitwise_or ::=
    exp PIPE exp

private binop_multiply_group ::=
    exp_multiply
  | exp_divide
  | exp_modulo
  | exp_wrapping_multiply

exp_multiply ::=
    exp STAR exp

exp_divide ::=
    exp SLASH exp

exp_modulo ::=
    exp PERCENT exp

exp_wrapping_multiply ::=
    exp WRAPPING_MUL exp

private binop_add_group ::=
    exp_plus
  | exp_minus
  | exp_wrapping_plus
  | exp_wrapping_minus
  | exp_concat

exp_minus ::=
    exp MINUS exp

exp_plus ::=
    exp PLUS exp

exp_wrapping_minus ::=
    exp WRAPPING_ADD exp

exp_wrapping_plus ::=
    exp WRAPPING_SUB exp

exp_concat ::=
    exp HASH exp

//parent node:<exp>
// ( <exp>,* )                                             tuple
exp_tuple ::=
    L_PAREN exp (COMA exp)* R_PAREN

//parent node:<exp>
// <exp> . <nat>                                           tuple projection
exp_tuple_projection ::=
    exp POINT NAT

//parent node:<exp>
// ? <exp>                                                 option injection
exp_option_injection ::=
    QUESTION exp

//parent node:<exp>
// { <exp-field>;* }                                       object
exp_object ::=
    L_CURL (exp_field SEMI)* R_CURL

//parent node:<exp>
// # id <exp>?                                             variant injection
exp_variant_injection ::=
    HASH ID exp?

//parent node:<exp>
// <exp> . <id>                                            object projection/member access
exp_object_projection ::=
    exp POINT ID

//parent node:<exp>
// <exp> := <exp>                                          assignment
exp_assignment::=
    exp IN_PLACE_UPDATE exp

//parent node:<exp>
// <unop>= <exp>                                           unary update

//parent node:<exp>
// <exp> <binop>= <exp>                                    binary update
private exp_binary_update ::=
    exp_binassign_in_place_update
  | exp_binassign_in_place_add
  | exp_binassign_in_place_subtract
  | exp_binassign_in_place_multiply
  | exp_binassign_in_place_divide
  | exp_binassign_in_place_modulo
  | exp_binassign_in_place_exponentiation
  | exp_binassign_in_place_logical_and
  | exp_binassign_in_place_logical_or
  | exp_binassign_in_place_exclusive_or
  | exp_binassign_in_place_shift_left
  | exp_binassign_in_place_shift_right
  | exp_binassign_in_place_rotate_left
  | exp_binassign_in_place_rotate_right
  | exp_binassign_in_place_add_wrap_on_overflow
  | exp_binassign_in_place_subtract_wrap_on_overflow
  | exp_binassign_in_place_multiply_wrap_on_overflow
  | exp_binassign_in_place_exponentiation_wrap_on_overflow
  | exp_binassign_in_place_concatenation

exp_binassign_in_place_update ::=
    exp IN_PLACE_UPDATE exp

exp_binassign_in_place_add ::=
    exp IN_PLACE_ADD exp

exp_binassign_in_place_subtract ::=
    exp IN_PLACE_SUBTRACT exp

exp_binassign_in_place_multiply ::=
    exp IN_PLACE_MULTIPLY exp

exp_binassign_in_place_divide ::=
    exp IN_PLACE_DIVIDE exp

exp_binassign_in_place_modulo ::=
    exp IN_PLACE_MODULO exp

exp_binassign_in_place_exponentiation ::=
    exp IN_PLACE_EXPONENTIATION exp

exp_binassign_in_place_logical_and ::=
    exp IN_PLACE_LOGICAL_AND exp

exp_binassign_in_place_logical_or ::=
    exp IN_PLACE_LOGICAL_OR exp

exp_binassign_in_place_exclusive_or ::=
    exp IN_PLACE_EXCLUSIVE_OR exp

exp_binassign_in_place_shift_left ::=
    exp IN_PLACE_SHIFT_LEFT exp

exp_binassign_in_place_shift_right ::=
    exp IN_PLACE_SHIFT_RIGHT exp

exp_binassign_in_place_rotate_left ::=
    exp IN_PLACE_ROTATE_LEFT exp

exp_binassign_in_place_rotate_right ::=
    exp IN_PLACE_ROTATE_RIGHT exp

exp_binassign_in_place_add_wrap_on_overflow ::=
    exp IN_PLACE_ADD_WRAP_ON_OVERFLOW exp

exp_binassign_in_place_subtract_wrap_on_overflow ::=
    exp IN_PLACE_SUBTRACT_WRAP_ON_OVERFLOW exp

exp_binassign_in_place_multiply_wrap_on_overflow ::=
    exp IN_PLACE_MULTIPLY_WRAP_ON_OVERFLOW exp

exp_binassign_in_place_exponentiation_wrap_on_overflow ::=
    exp IN_PLACE_EXPONENTIATION_WRAP_ON_OVERFLOW exp

exp_binassign_in_place_concatenation ::=
    exp IN_PLACE_CONCATENATION exp

//parent node:<exp>
// [ var? <exp>,* ]                                        array
// TODO: example with the use of var
exp_array ::=
    L_SQUARE VAR? exp? (COMA exp)* R_SQUARE

//parent node:<exp>
// <exp> [ <exp> ]                                         array indexing
exp_array_indexing ::=
    exp L_SQUARE exp R_SQUARE

//parent node:<exp>
// <shared-pat>? func <func_exp>                           function expression
//exp_function_expression ::=
//    shared_pat? FUNC func_exp

//parent node:<exp>
// <exp> <typ-args>? <exp>                                 function call
//exp_function_call ::=
//    exp typ_args? exp

//parent node:<exp>
// not <exp>                                               negation
exp_negation ::=
    NOT exp

//parent node:<exp>
// <exp> and <exp>                                         conjunction
exp_conjunction ::=
    exp AND exp

//parent node:<exp>
// <exp> or <exp>                                          disjunction
exp_disjunction ::=
    exp OR exp

//parent node:<exp>
// if <exp> <block-or-exp> (else <block-or-exp>)?          conditional
exp_conditional ::=
    IF exp block_or_exp (ELSE block_or_exp)?

//parent node:<exp>
// switch <exp> { (case <pat> <block-or-exp>;)+ }          switch
exp_switch ::=
    SWITCH L_PAREN exp R_PAREN L_CURL ( CASE pat block_or_exp SEMI )+ R_CURL

//<block-or-exp> ::=
//  <block>
//  <exp>
block_or_exp ::=
    block
  | exp

//<exp-field> ::=                      object expression fields
//  var? <id> (: <typ>) = <exp>        field
//  var? <id> (: <typ>)                punned field
// TODO: is there a missing '?' after (: <typ>) in the spec???
exp_field ::=
    VAR? ID (COLUMN typ)? EQ exp
  | VAR? ID (COLUMN typ)?

//<exp_nest> ::=
//    <block>
//    <exp>

exp_nest ::=
    block
  | exp

//<block> ::=
//    '{' <list(<dec>, ';')> '}'

block ::=
    L_CURL dec? (SEMI dec)* SEMI? R_CURL

//<case> ::=
//    'case' <pat_nullary> <exp_nest>

//<catch> ::=
//    'catch' <pat_nullary> <exp_nest>

//<exp_field> ::=
//    'var'? <id> (':' <typ>)?
//    'var'? <id> (':' <typ>)? '=' <exp>



//<dec-field> ::=              object declaration fields
//  <vis>? <stab>? <dec>       field

dec_field ::=
    vis? stab? dec

//<vis> ::=                    field visibility
//  public
//  private
//  system

vis ::=
    PRIVATE
  | PUBLIC
  | SYSTEM
  | empty

//<stab> ::=                   field stability (actor only)
//  stable
//  flexible

stab ::=
    FLEXIBLE
  | STABLE

//<pat_plain> ::=
//    '_'
//    <id>
//    <lit>
//    '(' <list(<pat_bin>, ',')> ')'

pat_plain ::=
    UNDERSCORE
  | ID
  | lit
  | L_PAREN pat_bin? (COMA pat_bin)* R_PAREN

//<pat_nullary> ::=
//    <pat_plain>
//    '{' <list(<pat_field>, ';')> '}'

private pat_nullary ::=
    pat_plain

//<pat_un> ::=
//    <pat_nullary>
//    '#' <id>
//    '#' <id> <pat_nullary>
//    '?' <pat_un>
//    <unop> <lit>

private pat_un ::=
    pat_nullary
  | pat_unop

pat_unop ::=
    PLUS lit
  | MINUS lit
  | CARRET lit

//<pat_bin> ::=
//    <pat_un>
//    <pat_bin> 'or' <pat_bin>
//    <pat_bin> ':' <typ>

private pat_bin ::=
    pat_un
//  | pat_bin_or
  | pat_bin_type

pat_bin_type ::=
    pat ':' typ

//<pat> ::=
//    <pat_bin>

pat ::=
    pat_bin

//<pat_field> ::=
//    <id> (':' <typ>)?
//    <id> (':' <typ>)? '=' <pat>

//<dec> ::=                                                                                declaration
//  <exp>                                                                                  expression
//  let <pat> = <exp>                                                                      immutable
//  var <id> (: <typ>)? = <exp>                                                            mutable
//  <sort> <id>? =? <obj-body>                                                             object
//  <shared-pat>? func <id>? <typ-params>? <pat> (: <typ>)? =? <exp>                       function
//  type <id> <typ-params>? = <typ>                                                        type
//  <shared-pat>? <sort>? class <id>? <typ-params>? <pat> (: <typ>)? <class-body>          class

dec ::=
    exp
  | LET pat EQ exp
  | VAR ID (COLUMN typ)? EQ exp
  | sort ID? EQ? obj_body
  | shared_pat? vis FUNC ID? typ_params? pat (COLUMN typ)? func_body
  | TYPE ID typ_params? EQ typ
  | shared_pat? sort? CLASS ID? typ_params? pat (COLUMN typ)? class_body

//<func_body> ::=
//    '=' <exp>
//    <block>

func_body ::=
    EQ exp
  | block

//<obj-body> ::=               object body
//   { <dec-field>;* }         field declarations

obj_body ::=
    L_CURL (dec_field SEMI)* R_CURL

//<class-body> ::=             class body
//    = <id>? <obj-body>       object body, optionally binding <id> to _this_ instance
//    <obj-body>               object body

class_body ::=
    EQ ID? obj_body
  | obj_body

//<imp> ::=
//    'import' <id>? '='? <text>

imp ::= IMPORT ID? EQ? url SEMI

url ::=
    TEXT

private imp_list ::= imp imp_list*
private dec_list ::= dec SEMI dec_list*

//<prog> ::=
//    <list(<imp>, ';')> <list(<dec>, ';')>

prog::= imp_list* dec_list* LINE_COMMENT* BLOCK_COMMENT*
